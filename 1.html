<!DOCTYPE html>
<html>
<head>
    <title>نمایش گرافیکی DFA</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f4f4f4;
            margin: 0;
        }

        #dfa-container {
            position: relative;
            width: 600px;
            height: 400px;
            border: 1px solid lightgray;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .state {
            width: 80px;
            height: 80px;
            border: 2px solid black;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: absolute;
            background-color: white;
            font-weight: bold;
            font-size: 16px;
            cursor: grab;
            user-select: none;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .accepting {
            border-color: green;
            border-width: 4px;
        }

        .start::before {
            content: '→ ';
            font-size: 20px;
            color: blue;
            position: absolute;
            left: -20px;
        }

        .edgeLabel {
            background-color: rgba(255, 255, 255, 0.8);
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body>
    <div id="dfa-container">
    </div>

    <script src="https://cdn.jsdelivr.net/npm/jsplumb@2.15.6/dist/js/jsplumb.min.js"></script>
    <script>
        //تعریف  dfa اولیه
        class DFA {
            constructor(states, alphabet, startState, acceptingStates, transitionFunction) {
                this.states = new Set(states);
                this.alphabet = new Set(alphabet);
                this.startState = startState;
                this.acceptingStates = new Set(acceptingStates);
                this.transitionFunction = transitionFunction;
            }

            transition(state, symbol) {
                return this.transitionFunction[`${state},${symbol}`];
            }
        }

        const dfa = new DFA(
            ['q0', 'q1', 'q2', 'q3'],
            ['a', 'b'],
            'q0',
            ['q3'],
            {
                'q0,a': 'q1',
                'q0,b': 'q2',
                'q1,a': 'q1',
                'q1,b': 'q3',
                'q2,a': 'q1',
                'q2,b': 'q2',
                'q3,a': 'q3',
                'q3,b': 'q3',
            }
        );


        console.log("DFA اولیه:", dfa);
        //جدول تمایز
        function createDistinguishabilityTable(states) {
            const table = {};
            const sortedStates = [...states].sort(); // برای ترتیب یکسان

            for (let i = 0; i < sortedStates.length; i++) {
                table[sortedStates[i]] = {};
                for (let j = i + 1; j < sortedStates.length; j++) {
                    table[sortedStates[i]][sortedStates[j]] = false; // false به معنی غیرقابل تشخیص در ابتدا
                }
            }
            return table;
        }

        const distinguishabilityTable = createDistinguishabilityTable(dfa.states);
        console.log("جدول تمایز اولیه:", distinguishabilityTable);

        // جدول تمایز بعد از پر کردن
        function fillDistinguishabilityTable(dfa, table) {
            const states = [...dfa.states].sort();
            let changed = true;

            // مرحله اول: علامت‌گذاری حالت‌های پایانی و غیرپایانی
            for (let i = 0; i < states.length; i++) {
                for (let j = i + 1; j < states.length; j++) {
                    const state1 = states[i];
                    const state2 = states[j];
                    const isState1Accepting = dfa.acceptingStates.has(state1);
                    const isState2Accepting = dfa.acceptingStates.has(state2);

                    if (isState1Accepting !== isState2Accepting) {
                        table[state1][state2] = true;
                    }
                }
            }

            // مرحله دوم: بررسی انتقال‌ها به صورت تکراری
            while (changed) {
                changed = false;
                for (let i = 0; i < states.length; i++) {
                    for (let j = i + 1; j < states.length; j++) {
                        const state1 = states[i];
                        const state2 = states[j];

                        if (!table[state1]?.[state2] && !table[state2]?.[state1]) { // اگر هنوز غیرقابل تشخیص است
                            for (const symbol of dfa.alphabet) {
                                const nextState1 = dfa.transition(state1, symbol);
                                const nextState2 = dfa.transition(state2, symbol);

                                // بررسی ترتیب برای دسترسی به جدول
                                const s1 = nextState1 < nextState2 ? nextState1 : nextState2;
                                const s2 = nextState1 < nextState2 ? nextState2 : nextState1;

                                if (s1 !== s2 && (table[s1]?.[s2] || table[s2]?.[s1])) {
                                    table[state1][state2] = true;
                                    changed = true;
                                    break; // نیازی به بررسی نمادهای دیگر نیست
                                }
                            }
                        }
                    }
                }
            }
        }

        fillDistinguishabilityTable(dfa, distinguishabilityTable);
        console.log("جدول تمایز پس از پر کردن:", distinguishabilityTable);
        function groupUndistinguishableStates(states, table) {
            const groups = [];
            const visited = new Set();
            const sortedStates = [...states].sort();

            for (const state of sortedStates) {
                if (!visited.has(state)) {
                    const group = [state];
                    visited.add(state);
                    for (const otherState of sortedStates) {
                        if (state !== otherState && !visited.has(otherState)) {
                            const s1 = state < otherState ? state : otherState;
                            const s2 = state < otherState ? otherState : state;
                            if (!table[s1]?.[s2] && !table[s2]?.[s1]) {
                                group.push(otherState);
                                visited.add(otherState);
                            }
                        }
                    }
                    groups.push(group);
                }
            }
            return groups;
        }

        const stateGroups = groupUndistinguishableStates(dfa.states, distinguishabilityTable);
        console.log("گروه‌های حالت‌های غیرقابل تشخیص:", stateGroups);
        function createMinimalDFA(dfa, stateGroups) {
            const minimalStates = stateGroups.map((group, index) => `Q${index}`);
            const minimalStartState = stateGroups.findIndex(group => group.includes(dfa.startState));
            const minimalAcceptingStates = new Set(
                stateGroups.filter(group => group.some(state => dfa.acceptingStates.has(state))).map((_, index) => `Q${index}`)
            );
            const minimalTransitionFunction = {};

            for (let i = 0; i < stateGroups.length; i++) {
                const group = stateGroups[i];
                const minimalState = `Q${i}`;
                for (const symbol of dfa.alphabet) {
                    const representativeState = group[0]; // انتخاب اولین حالت به عنوان نماینده
                    const nextState = dfa.transition(representativeState, symbol);
                    const nextGroupIndex = stateGroups.findIndex(g => g.includes(nextState));
                    minimalTransitionFunction[`${minimalState},${symbol}`] = `Q${nextGroupIndex}`;
                }
            }

            return new DFA(
                minimalStates,
                [...dfa.alphabet],
                `Q${minimalStartState}`,
                minimalAcceptingStates,
                minimalTransitionFunction
            );
        }

        const minimalDFA = createMinimalDFA(dfa, stateGroups);
        console.log("DFA کمینه:", minimalDFA);

        const dfaContainer = document.getElementById('dfa-container');

        const statePositions = {
            'q0': { top: '50px', left: '50px' },
            'q1': { top: '50px', left: '350px' },
            'q2': { top: '250px', left: '150px' },
            'q3': { top: '250px', left: '450px' }
        };

        for (const state of dfa.states) {
            const stateElement = document.createElement('div');
            stateElement.classList.add('state');
            stateElement.textContent = state;
            stateElement.style.top = statePositions[state].top;
            stateElement.style.left = statePositions[state].left;
            stateElement.id = state; // استفاده از ID برای jsPlumb

            if (dfa.acceptingStates.has(state)) {
                stateElement.classList.add('accepting');
            }
            if (dfa.startState === state) {
                stateElement.classList.add('start');
            }

            dfaContainer.appendChild(stateElement);
        }

        jsPlumb.ready(function() {
            console.log("jsPlumb is ready!");
            const instance = jsPlumb.getInstance({
                container: dfaContainer
            });

            const commonEndpoint = {
                isSource: true,
                isTarget: true,
                maxConnections: -1,
                connector: ["Flowchart", { stub: [40, 60], gap: 5, cornerRadius: 5 }],
                endpoint: ["Dot", { radius: 5 }],
                paintStyle: { fill: "black", radius: 5 },
                hoverPaintStyle: { fill: "blue" },
                anchor: "Continuous"
            };

            for (const key in dfa.transitionFunction) {
                const [fromState, symbol] = key.split(',');
                const toState = dfa.transitionFunction[key];
                console.log(`Connecting ${fromState} to ${toState} with symbol ${symbol}`); // این خط را اضافه کنید
                instance.connect({
                    source: fromState,
                    target: toState,
                    endpoint: "Blank",
                    overlays: [
                        ["Arrow", { width: 12, length: 12, location: 1 }],
                        ["Label", { label: symbol, cssClass: "edgeLabel", location: 0.5 }]
                    ]
                }, commonEndpoint);
            }
        });
    </script>
</body>
</html>